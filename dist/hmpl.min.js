!function(e,t){"object"==typeof module&&module.exports?module.exports=t():"function"==typeof define&&define.amd?define([],t):e.hmpl=e.hmpl||t()}("undefined"!=typeof self?self:this,(function(){return function(){"use strict";const e=e=>"object"==typeof e&&!Array.isArray(e)&&null!==e,t=e=>{throw new Error(e)},o=e=>{console.warn(e)},n="method",s="after",r="mode",l=/([{}])/,i=(n,s,r,l,i,d,c,a={},f,h)=>{const{mode:p,cache:u,redirect:m,get:g,referrerPolicy:y,signal:v,credentials:N,timeout:b,referrer:w,headers:T,body:E,window:C,integrity:j}=a,O={method:l.toUpperCase()};void 0!==N&&(O.credentials=N),void 0!==E&&(O.body=E),void 0!==p&&(O.mode=p),void 0!==u&&(O.cache=u),void 0!==m&&(O.redirect=m),void 0!==y&&(O.referrerPolicy=y),void 0!==j&&(O.integrity=j),void 0!==w&&(O.referrer=w);const x=void 0!==v;if(x&&(O.signal=v),void 0!==C&&(O.window=C),void 0!==a.keepalive&&o("keepalive property is not yet supported"),T)if(e(T)){const e=new Headers;for(const o in T){const[n,s]=o;if("string"==typeof s)try{e.set(n,s)}catch(e){throw e}else t("Header has no string value")}O.headers=e}else t('The "header" property does not have a value object');b&&(x?o("The signal property overwrote the AbortSignal from timeout"):O.signal=AbortSignal.timeout(b));const I=e=>{c?h.status!==e&&(h.status=e,g?.("status",e,h)):f.status!==e&&(f.status=e,g?.("status",e))};I(0),fetch(i,O).then((e=>(I(e.status),e.ok||t(`Request error with code ${e.status}`),e.text()))).then((e=>{const o=(e=>{"string"!=typeof e&&t("Bad response");const o=(new DOMParser).parseFromString(`<template>${e}</template>`,"text/html").childNodes[0].childNodes[0].firstChild,n=o.content,s=n.querySelectorAll("script");for(let e=0;e<s.length;e++){const t=s[e];n.removeChild(t)}return o})(e);if(d)f.response=o,g?.("response",o);else{let e=[];const l=o.content.childNodes;if(r)if(r.nodes){const o=r.parentNode;o||t("parentNode is null");const n=[],s=r.nodes.length;for(let e=0;e<s;e++){const t=r.nodes[e];if(e===s-1)for(let e=0;e<l.length;e++){const s=l[e],r=o.insertBefore(s,t);n.push(r)}o.removeChild(t)}e=n.slice(),r.nodes=n}else{const t=n.parentNode,o=[];for(let e=0;e<l.length;e++){const s=l[e],r=t.insertBefore(s,n);o.push(r)}t.removeChild(n),e=o.slice(),r.nodes=o,r.parentNode=t}else{const t=n.parentNode;for(let o=0;o<l.length;o++){const s=l[o],r=t.insertBefore(s,n);c&&e.push(r)}t.removeChild(n)}c&&(h.response=e,g?.("response",e,h)),g?.("response",s)}})).catch((e=>{throw e}))},d=e=>{var o;e.get&&(o=e.get,"[object Function]"!==Object.prototype.toString.call(o)&&t("The get property has a function value"))};return{compile:o=>{"string"!=typeof o&&t("template was not found or the type of the passed value is not string"),o||t("template empty");const c=[],a=o.split(l).filter(Boolean);let f,h,p=-1,u="";for(let e=0;e<a.length;e++){const o=a[e],l="}"===o;if("{"===o)p>0&&t("Object nesting error"),-1===p?h={startId:e,endId:NaN}:h&&(u+=o),p++,f=!0;else if(l)if(f&&0===p&&t("There are no query objects between the brackets"),-1===p)t("Template error");else if(-1==--p&&void 0!==f){const o=e=>e=(e=e.trim()).replace(/\r?\n|\r/g,""),l=o(u),i=JSON.parse(l);for(const e in i){const o=i[e];"src"!==e&&e!==n&&"ref"!==e&&e!==s&&e!==r&&t(`Property ${e} is not processed`),"string"!=typeof o&&t(`The value of the property ${e} must be a string`)}h.endId=e;const d={...i,...h};c.push(d),f=void 0,h=void 0,u=""}else h&&(u+=o),f=!1;else h&&(u+=o)}0===c.length&&t("Request not found");let m=0;for(let e=0;e<c.length;e++){const t=c[e],o=`\x3c!--hmpl${e}--\x3e`,{startId:n,endId:s}=t,r=s-n;a.splice(n-m,r+1,o),m+=s-n,delete t.startId,delete t.endId}o=a.join("");let g=!1;const y=(e=>{const o=(new DOMParser).parseFromString(`<template>${e}</template>`,"text/html").childNodes[0].childNodes[0].firstChild;o.content.children.length>1&&t('Template include only one node with type "Element" or "Comment"');const n=e=>{switch(e.nodeType){case Node.ELEMENT_NODE:if("pre"===e.tagName)return;break;case Node.TEXT_NODE:if(!/\S/.test(e.textContent))return void e.remove()}for(let t=0;t<e.childNodes.length;t++)n(e.childNodes.item(t))};n(o.content.childNodes[0]);let s=o.content.firstElementChild;if(!s){const e=o.content.firstChild,n=8===e?.nodeType;n?(g=n,s=e):t("Element is undefined")}return s})(o);return((e,o,l,d=!1)=>{const c=(e,o)=>{const l=e.src;if(l){const c=(e.method||"GET").toLowerCase();if(!(e=>"get"!==e&&"post"!==e&&"put"!==e&&"delete"!==e&&"patch"!==e)(c)){const n=e.after;n&&d&&t("EventTarget is undefined");const a=e.mode,f=(a||"all").toLowerCase();"one"!==f&&"all"!==f&&t(`${r} has only ONE or ALL values`);const h=e.ref,p="all"===f,u=e.nodeId,m=(e,o=!1)=>{if(o){if(h){let o;for(let t=0;t<e.length;t++){const n=e[t];if(n.id===h){o=n.options;break}}return o||t("id referenced by request not found"),o}return{}}return h&&t("id referenced by request not found"),e},g=p&&n,y=(e,n,s,r,a,f=!1,h,p=!1,y)=>{const v=r.currentId;if(d)e||(e=o);else if(!e)if(y)e=y.el;else{let o;const{els:n}=r;for(let e=0;e<n.length;e++){const t=n[e];if(t.id===u){y=t,o=t.el;break}}o||t("Element error"),e=o}let N;g&&(y||t("Element error"),N=y.objNode,N||(N={id:v,nodes:null,parentNode:null},y.objNode=N,r.dataObjects.push(N),r.currentId++));const b=m(n,f);i(e,a,N,c,l,d,p,b,s,h)};let v=y;if(n){const e=(e,o,n,s,r,l,i,d,c,a,f)=>{const h=c.querySelectorAll(n);0===h.length&&t("Selectors nodes not found");const u=p?()=>{y(e,s,r,l,c,i,a,d,f)}:()=>{y(e,s,r,l,c,i,a,d,f);for(let e=0;e<h.length;e++)h[e].removeEventListener(o,u)};for(let e=0;e<h.length;e++)h[e].addEventListener(o,u)};if(n.indexOf(":")>0){const t=n.split(":"),o=t[0],s=t.slice(1).join(":");v=(t,n,r,l,i,d=!1,c,a=!1,f)=>{e(t,o,s,n,r,l,d,a,i,c,f)}}else t(`${s} attribute doesn't work without EventTargets`)}else a&&t(`${r} attribute doesn't work without ${s}`);return v}t(`${n} has only GET, POST, PUT, PATCH or DELETE values`)}else t('The "source" attribute are not found or empty')};let a;if(d)l[0].el=e,a=c(l[0]);else{let o=-2;const n=e=>{if(o++,8==e.nodeType){let n=e.nodeValue;if(n&&n.startsWith("hmpl")){n=n.slice(4);const s=Number(n),r=l[s];(Number.isNaN(s)||void 0===r)&&t("Request index error"),r.el=e,r.nodeId=o}}if(e.hasChildNodes()){const t=e.childNodes;for(let e=0;e<t.length;e++)n(t[e])}};n(e);const s=[];for(let t=0;t<l.length;t++){const o=l[t];s.push(c(o,e))}if(l.length>1)a=(e,o,n,r,l,i=!1)=>{e||(e=l);const d=[],c=r.els;for(let l=0;l<c.length;l++){const a=c[l],f=a.el;null===f.parentNode&&t('"parentNode" is null');const h={response:void 0,status:0};(0,s[l])(f,o,n,r,e,i,h,!0,a),d.push(h)}n.requests=d};else{const o=l[0];null===o.el.parentNode&&t('"parentNode" is null'),a=c(o,e)}}return o(a)})(y,(o=>(n={})=>{const s=y.cloneNode(!0),r={response:g?void 0:s};g&&(r.status=0);const l={dataObjects:[],els:[],currentId:0};if(!g){let e=-2;const t=o=>{if(e++,8==o.nodeType){const t=o.nodeValue;if(t&&t.startsWith("hmpl")){const t={el:o,id:e};l.els.push(t)}}if(o.hasChildNodes()){const e=o.childNodes;for(let o=0;o<e.length;o++)t(e[o])}};t(s)}return e(n)?(d(n),o(void 0,n,r,l,s)):Array.isArray(n)&&((o=>{const n=[];for(let s=0;s<o.length;s++){const r=o[s];e(r)||t('options is of type "object"'),d(r);const{id:l}=r;"string"!=typeof r.id&&t('id is of type "string"'),n.indexOf(l)>-1?t(`id with value "${l}" already exists`):n.push(l)}})(n),o(void 0,n,r,l,s,!0)),r}),c,g)},stringify:e=>JSON.stringify(e)}}()}));